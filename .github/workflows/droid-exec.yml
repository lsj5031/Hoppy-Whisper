name: droid-exec

on:
  issue_comment:
    types: [created]

jobs:
  run-droid-exec:
    if: >
      contains(github.event.comment.body, '/droid') ||
      contains(github.event.comment.body, '/droid-exec')
    runs-on: windows-latest
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install Factory CLI
        shell: pwsh
        run: |
          Set-ExecutionPolicy -Scope Process -ExecutionPolicy RemoteSigned -Force
          irm https://app.factory.ai/cli/windows | iex
          $userBin = Join-Path $Env:USERPROFILE 'bin'
          $factoryBin = Join-Path $Env:USERPROFILE '.factory\bin'
          foreach ($path in @($userBin, $factoryBin)) {
            if (Test-Path $path) {
              Add-Content -Path $env:GITHUB_PATH -Value $path
            }
          }

      - name: Extract droid prompt
        id: prompt
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = (context.payload.comment.body || '').trim();
            const match = body.match(/\/droid(?:-exec)?/i);

            if (!match) {
              core.setFailed('No /droid command found in the comment body.');
              return;
            }

            const prompt = body.slice(match.index + match[0].length).trim();
            if (!prompt) {
              core.setFailed('Please provide instructions after the /droid command.');
              return;
            }

            const optionsDefault = '--skip-permissions-unsafe';
            let optionsText = '';
            let requestText = prompt;

            const newlineIndex = prompt.indexOf('\n');
            if (prompt.startsWith('--')) {
              if (newlineIndex === -1) {
                optionsText = prompt.trim();
                requestText = '';
              } else {
                optionsText = prompt.slice(0, newlineIndex).trim();
                requestText = prompt.slice(newlineIndex + 1).trim();
              }
            }

            if (!optionsText) {
              optionsText = optionsDefault;
            }

            if (!requestText) {
              core.setFailed('Please provide instructions after any flags.');
              return;
            }

            const {owner, repo} = context.repo;
            const issue_number = context.issue.number;

            const issueResp = await github.rest.issues.get({
              owner,
              repo,
              issue_number,
            });

            let allComments = [];
            let page = 1;
            while (true) {
              const commentsResp = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number,
                per_page: 100,
                page,
              });
              if (!commentsResp.data.length) {
                break;
              }
              allComments = allComments.concat(commentsResp.data);
              if (commentsResp.data.length < 100) {
                break;
              }
              page += 1;
            }

            const otherComments = allComments
              .filter(comment => comment.id !== context.payload.comment.id)
              .map(comment => {
                const author = comment.user?.login ? `@${comment.user.login}` : 'unknown';
                const timestamp = comment.created_at || 'unknown time';
                const commentBody = (comment.body || '').trim() || '(empty comment)';
                return `Comment by ${author} on ${timestamp}:\n${commentBody}`;
              });

            const issueTitle = issueResp.data.title || '(untitled)';
            const issueBody = (issueResp.data.body || '').trim() || '(no description provided)';

            const sections = [
              '# Issue Context',
              `Title: ${issueTitle}`,
              '',
              'Body:',
              issueBody,
            ];

            if (otherComments.length) {
              sections.push('', '## Other Comments', ...otherComments);
            }

            sections.push('', '## Execution Options', optionsText);
            sections.push('', '## Request', requestText);

            const fullPrompt = sections.join('\n');

            fs.writeFileSync('prompt.txt', fullPrompt, 'utf8');
            core.setOutput('prompt', requestText);
            core.setOutput('options', optionsText);
            core.setOutput('command', match[0]);

      - name: Run droid exec
        id: droid
        shell: pwsh
        continue-on-error: true
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
          FACTORY_ORG: ${{ secrets.FACTORY_ORG }}
          DROID_EXEC_OPTIONS: ${{ steps.prompt.outputs.options }}
        run: |
          $ErrorActionPreference = 'Continue'
          $logPath = Join-Path $PWD 'droid-output.txt'
          if (-not (Test-Path $logPath)) {
            New-Item -ItemType File -Path $logPath -Force | Out-Null
          }
          if (Get-Command droid -ErrorAction SilentlyContinue) {
            $options = $env:DROID_EXEC_OPTIONS
            if ([string]::IsNullOrWhiteSpace($options)) {
              $optionArgs = @()
            } else {
              $optionArgs = $options -split '\s+'
            }
            $arguments = @('exec') + $optionArgs + @('--output-format', 'text', '-f', 'prompt.txt')
            & droid @arguments 2>&1 | Tee-Object -FilePath $logPath -Encoding UTF8
            $exitCode = $LASTEXITCODE
          } else {
            $message = "droid executable not found on PATH. Current PATH:`n$env:PATH"
            $message | Tee-Object -FilePath $logPath -Encoding UTF8
            $exitCode = 127
          }
          "exit_code=$exitCode" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          exit $exitCode

      - name: Post droid exec results
        if: always()
        uses: actions/github-script@v7
        env:
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          COMMENT_AUTHOR: ${{ github.event.comment.user.login }}
          COMMAND_USED: ${{ steps.prompt.outputs.command }}
          PROMPT_TEXT: ${{ steps.prompt.outputs.prompt }}
          STEP_OUTCOME: ${{ steps.droid.outcome }}
          EXIT_CODE: ${{ steps.droid.outputs.exit_code }}
          EXEC_OPTIONS: ${{ steps.prompt.outputs.options }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const outputPath = path.join(process.cwd(), 'droid-output.txt');
            let output = fs.existsSync(outputPath) ? fs.readFileSync(outputPath, 'utf8') : '(no output captured)';

            // Strip ANSI escape codes for readability.
            output = output.replace(/\u001B\[[0-9;]*m/g, '');

            const limit = 60000;
            let truncated = false;
            if (output.length > limit) {
              output = output.slice(0, limit);
              truncated = true;
            }

            const lines = [];
            const outcome = process.env.STEP_OUTCOME || 'failure';
            const statusEmoji = outcome === 'success' ? ':white_check_mark:' : ':warning:';
            const exitCode = process.env.EXIT_CODE || '1';
            const execOptions = process.env.EXEC_OPTIONS || '(default)';

            lines.push(`${statusEmoji} \`${process.env.COMMAND_USED || '/droid'}\` triggered by @${process.env.COMMENT_AUTHOR}`);
            lines.push(`Options: \`${execOptions}\``);
            if (outcome !== 'success') {
              lines.push(`droid exec exited with status \`${exitCode}\`.`);
            }
            lines.push('');
            lines.push('```\n' + output + '\n```');
            if (truncated) {
              lines.push('_Output truncated to 60k characters._');
            }
            lines.push('');
            lines.push(`[View workflow run](${process.env.RUN_URL})`);

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: lines.join('\n')
            });

      - name: Fail workflow when droid exec fails
        if: ${{ steps.droid.outcome == 'failure' }}
        shell: pwsh
        run: |
          Write-Host "droid exec exited with status ${{ steps.droid.outputs.exit_code }}."
          exit 1

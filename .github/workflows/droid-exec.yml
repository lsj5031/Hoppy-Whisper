name: droid-exec

on:
  issue_comment:
    types: [created]

jobs:
  run-droid-exec:
    if: >
      contains(github.event.comment.body, '/droid') ||
      contains(github.event.comment.body, '/droid-exec')
    runs-on: windows-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install Factory CLI
        shell: pwsh
        run: |
          Set-ExecutionPolicy -Scope Process -ExecutionPolicy RemoteSigned -Force
          irm https://app.factory.ai/cli/windows | iex
          $userBin = Join-Path $Env:USERPROFILE 'bin'
          $factoryBin = Join-Path $Env:USERPROFILE '.factory\bin'
          foreach ($path in @($userBin, $factoryBin)) {
            if (Test-Path $path) {
              Add-Content -Path $env:GITHUB_PATH -Value $path
            }
          }

      - name: Extract droid prompt
        id: prompt
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const body = (context.payload.comment.body || '').trim();
            const match = body.match(/\/droid(?:-exec)?/i);

            if (!match) {
              core.setFailed('No /droid command found in the comment body.');
              return;
            }

            const prompt = body.slice(match.index + match[0].length).trim();
            if (!prompt) {
              core.setFailed('Please provide instructions after the /droid command.');
              return;
            }

            const optionsDefault = '--skip-permissions-unsafe';
            let optionsText = '';
            let requestText = prompt;

            const newlineIndex = prompt.indexOf('\n');
            if (prompt.startsWith('--')) {
              if (newlineIndex === -1) {
                optionsText = prompt.trim();
                requestText = '';
              } else {
                optionsText = prompt.slice(0, newlineIndex).trim();
                requestText = prompt.slice(newlineIndex + 1).trim();
              }
            }

            if (!optionsText) {
              optionsText = optionsDefault;
            }

            if (!requestText) {
              core.setFailed('Please provide instructions after any flags.');
              return;
            }

            const {owner, repo} = context.repo;
            const issue_number = context.issue.number;

            const issueResp = await github.rest.issues.get({
              owner,
              repo,
              issue_number,
            });

            let allComments = [];
            let page = 1;
            while (true) {
              const commentsResp = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number,
                per_page: 100,
                page,
              });
              if (!commentsResp.data.length) {
                break;
              }
              allComments = allComments.concat(commentsResp.data);
              if (commentsResp.data.length < 100) {
                break;
              }
              page += 1;
            }

            const otherComments = allComments
              .filter(comment => comment.id !== context.payload.comment.id)
              .map(comment => {
                const author = comment.user?.login ? `@${comment.user.login}` : 'unknown';
                const timestamp = comment.created_at || 'unknown time';
                const commentBody = (comment.body || '').trim() || '(empty comment)';
                return `Comment by ${author} on ${timestamp}:\n${commentBody}`;
              });

            const issueTitle = issueResp.data.title || '(untitled)';
            const issueBody = (issueResp.data.body || '').trim() || '(no description provided)';

            const sections = [
              '# Issue Context',
              `Title: ${issueTitle}`,
              '',
              'Body:',
              issueBody,
            ];

            if (otherComments.length) {
              sections.push('', '## Other Comments', ...otherComments);
            }

            sections.push('', '## Execution Options', optionsText);
            sections.push('', '## Request', requestText);

            const fullPrompt = sections.join('\n');
            const promptPath = path.join(process.env.RUNNER_TEMP || process.cwd(), 'prompt.txt');
            fs.writeFileSync(promptPath, fullPrompt, 'utf8');
            core.setOutput('prompt', requestText);
            core.setOutput('options', optionsText);
            core.setOutput('issue_title', issueTitle);
            core.setOutput('command', match[0]);
            core.setOutput('prompt_path', promptPath);

      - name: Run droid exec
        id: droid
        shell: pwsh
        continue-on-error: true
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
          FACTORY_ORG: ${{ secrets.FACTORY_ORG }}
          DROID_EXEC_OPTIONS: ${{ steps.prompt.outputs.options }}
          PROMPT_FILE: ${{ steps.prompt.outputs.prompt_path }}
        run: |
          $ErrorActionPreference = 'Continue'
          $logPath = Join-Path $env:RUNNER_TEMP 'droid-output.txt'
          if (-not (Test-Path $logPath)) {
            New-Item -ItemType File -Path $logPath -Force | Out-Null
          }
          if (Get-Command droid -ErrorAction SilentlyContinue) {
            $options = $env:DROID_EXEC_OPTIONS
            if ([string]::IsNullOrWhiteSpace($options)) {
              $optionArgs = @()
            } else {
              $optionArgs = $options -split '\s+'
            }
            $arguments = @('exec') + $optionArgs + @('--output-format', 'text', '-f', $env:PROMPT_FILE)
            & droid @arguments 2>&1 | Tee-Object -FilePath $logPath -Encoding UTF8
            $exitCode = $LASTEXITCODE
          } else {
            $message = "droid executable not found on PATH. Current PATH:`n$env:PATH"
            $message | Tee-Object -FilePath $logPath -Encoding UTF8
            $exitCode = 127
          }
          "exit_code=$exitCode" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          exit $exitCode

      - name: Prepare branch name
        id: branch
        if: ${{ steps.droid.outcome == 'success' }}
        uses: actions/github-script@v7
        env:
          ISSUE_TITLE: ${{ steps.prompt.outputs.issue_title }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        with:
          script: |
            const slugify = (input) => input
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-+|-+$/g, '')
              .slice(0, 40) || 'changes';
            const title = process.env.ISSUE_TITLE || '';
            const number = process.env.ISSUE_NUMBER;
            const branch = `issue-${number}-${slugify(title)}`;
            core.setOutput('branch', branch);

      - name: Commit and push changes
        id: commit
        if: ${{ steps.droid.outcome == 'success' }}
        shell: pwsh
        env:
          BRANCH_NAME: ${{ steps.branch.outputs.branch }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          $status = git status --porcelain
          if (-not $status) {
            Write-Host "No changes detected; skipping commit."
            Add-Content -Path $env:GITHUB_OUTPUT -Value "changes=false"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "branch="
            exit 0
          }

          $baseBranch = $env:BRANCH_NAME
          if ([string]::IsNullOrWhiteSpace($baseBranch)) {
            $baseBranch = "issue-$($env:ISSUE_NUMBER)-changes"
          }

          $branch = $baseBranch
          $suffix = 1
          $remote = git ls-remote --heads origin $branch
          while ($remote) {
            $branch = "$baseBranch-$suffix"
            $suffix++
            $remote = git ls-remote --heads origin $branch
          }

          git checkout -b $branch
          git add --all
          $commitMessage = "Apply droid updates for #$($env:ISSUE_NUMBER)"
          git commit -m $commitMessage
          git push --set-upstream origin $branch

          Add-Content -Path $env:GITHUB_OUTPUT -Value "changes=true"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "branch=$branch"

      - name: Create pull request
        id: create_pr
        if: ${{ steps.commit.outputs.changes == 'true' }}
        uses: actions/github-script@v7
        env:
          BRANCH: ${{ steps.commit.outputs.branch }}
          BASE: ${{ github.event.repository.default_branch }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ steps.prompt.outputs.issue_title }}
          EXEC_OPTIONS: ${{ steps.prompt.outputs.options }}
          REQUEST_TEXT: ${{ steps.prompt.outputs.prompt }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = process.env.BRANCH;
            if (!branch) {
              core.setOutput('pr_url', '');
              core.setOutput('pr_error', '');
              return;
            }
            const base = process.env.BASE || (context.payload.repository && context.payload.repository.default_branch) || 'master';
            const issueNumber = process.env.ISSUE_NUMBER;
            const issueTitle = process.env.ISSUE_TITLE || '';
            const execOptions = process.env.EXEC_OPTIONS;
            const requestText = process.env.REQUEST_TEXT || '';
            const headRef = `${owner}:${branch}`;
            try {
              const existing = await github.rest.pulls.list({
                owner,
                repo,
                head: headRef,
                state: 'open',
                per_page: 1,
              });
              let pr;
              if (existing.data.length) {
                pr = existing.data[0];
              } else {
                const title = `Droid updates for #${issueNumber}: ${issueTitle}`.trim();
                const bodyLines = [
                  'Automated changes triggered by `/droid`.',
                  '',
                  `- Issue: #${issueNumber}`,
                  `- Title: ${issueTitle}`,
                  `- Options: \`${execOptions || '(default)'}\``,
                ];
                const excerpt = requestText.replace(/\s+/g, ' ').slice(0, 200);
                if (excerpt) {
                  bodyLines.push('', 'Request:', '', '```', excerpt, '```');
                }
                pr = (await github.rest.pulls.create({
                  owner,
                  repo,
                  head: branch,
                  base,
                  title,
                  body: bodyLines.join('\n'),
                })).data;
              }
              core.setOutput('pr_url', pr.html_url);
              core.setOutput('pr_error', '');
            } catch (error) {
              if (error.status === 403) {
                core.warning(`PR creation skipped: ${error.message}`);
                core.setOutput('pr_url', '');
                core.setOutput('pr_error', error.message || 'Forbidden');
              } else {
                throw error;
              }
            }

      - name: Post droid exec results
        if: always()
        uses: actions/github-script@v7
        env:
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          COMMENT_AUTHOR: ${{ github.event.comment.user.login }}
          COMMAND_USED: ${{ steps.prompt.outputs.command }}
          PROMPT_TEXT: ${{ steps.prompt.outputs.prompt }}
          STEP_OUTCOME: ${{ steps.droid.outcome }}
          EXIT_CODE: ${{ steps.droid.outputs.exit_code }}
          EXEC_OPTIONS: ${{ steps.prompt.outputs.options }}
          BRANCH_CREATED: ${{ steps.commit.outputs.changes }}
          BRANCH_NAME: ${{ steps.commit.outputs.branch }}
          PR_URL: ${{ steps.create_pr.outputs.pr_url }}
          PR_ERROR: ${{ steps.create_pr.outputs.pr_error }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const outputPath = path.join(process.env.RUNNER_TEMP || process.cwd(), 'droid-output.txt');
            let output = fs.existsSync(outputPath) ? fs.readFileSync(outputPath, 'utf8') : '(no output captured)';

            // Strip ANSI escape codes for readability.
            output = output.replace(/\u001B\[[0-9;]*m/g, '');

            const limit = 60000;
            let truncated = false;
            if (output.length > limit) {
              output = output.slice(0, limit);
              truncated = true;
            }

            const lines = [];
            const outcome = process.env.STEP_OUTCOME || 'failure';
            const statusEmoji = outcome === 'success' ? ':white_check_mark:' : ':warning:';
            const exitCode = process.env.EXIT_CODE || '1';
            const execOptions = process.env.EXEC_OPTIONS || '(default)';
            const branchCreated = process.env.BRANCH_CREATED === 'true';
            const branchName = process.env.BRANCH_NAME;
            const prUrl = process.env.PR_URL;
            const prError = process.env.PR_ERROR;

            lines.push(`${statusEmoji} \`${process.env.COMMAND_USED || '/droid'}\` triggered by @${process.env.COMMENT_AUTHOR}`);
            lines.push(`Options: \`${execOptions}\``);
            if (branchCreated) {
              if (branchName) {
                lines.push(`Branch: \`${branchName}\``);
              }
              if (prUrl) {
                lines.push(`[View pull request](${prUrl})`);
              } else if (prError) {
                lines.push(`PR creation skipped: ${prError}`);
              }
            } else if (outcome === 'success') {
              lines.push('No code changes were generated by this run.');
            }
            if (outcome !== 'success') {
              lines.push(`droid exec exited with status \`${exitCode}\`.`);
            }
            lines.push('');
            lines.push('```\n' + output + '\n```');
            if (truncated) {
              lines.push('_Output truncated to 60k characters._');
            }
            lines.push('');
            lines.push(`[View workflow run](${process.env.RUN_URL})`);

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: lines.join('\n')
            });

      - name: Fail workflow when droid exec fails
        if: ${{ steps.droid.outcome == 'failure' }}
        shell: pwsh
        run: |
          Write-Host "droid exec exited with status ${{ steps.droid.outputs.exit_code }}."
          exit 1
